---
layout: post
title: Shared Objects
tags:
- dynamic linking
- miscellany
- shared objects
- static linking
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_old_slug: ''
---
Shared objects are great.  Imagine you have several programs running that all make use of the same library.  If they are all statically linked against that library, then there will be several copies of essentially the same code in memory.  Shared objects allow all these programs to reference the same code, held in memory in only one spot.

I've recently been spending a lot of time trying to get a few key libraries compiled on a cluster, where the idea is to run jobs based on these libraries in parallel.  As memory is particularly limited, and there are several cores per node, I figured it would particularly make sense to compile everything as a shared object.  Also, a subsequent library depended on it.

A lot of different packages configure, build and install themselves in a number of ways and often don't adhere to conventions.  Despite trying every flag known to man into the configuration tools, I was unable to get a particular piece to build as a shared object.  But I happened upon a <a href="http://www.tipcache.com/tip/Convert_a_static_library_(.a)_to_a_shared_object_(.so)_12.html">particularly useful code snippet</a> to save the day:
<code>
ar -x mylib.a
gcc -shared *.o -o mylib.so
</code>
