---
layout: post
title: Python and Arbitrary Function Arguments - **kwargs
tags:
- computer science
- keyword arguments
- kwargs
- python
- Python
status: publish
type: post
published: true
meta:
  _edit_last: '2'
---
Python has a pretty useful policy: named arguments. When you call a function, you can explicitly say that such-and-such value is what you're providing for a particular argument, and can even include them in any order:

<pre lang='python'>
def hello(first, last):
	print 'Hello %s %s' % (first, last)

hello(last='Lecocq', first='Dan')
</pre>

In fact, you can programmatically gain insight into functions with the <a href="http://docs.python.org/library/inspect.html" title="inspect" target="_blank">inspect module</a>. But suppose you want to be able to accept an arbitrary number of parameters. For example, for a printf equivalent. Or where I encountered it in wanting to read a module name from a configuration file, as well as the arguments to instantiate it. In this case, you'd get the module and class as a string and then a dictionary of the arguments to make an instance of it. Of course, Python always has a way. In this case, **kwargs.

This is actually dictionary unpacking, taking all the keys in a dictionary and mapping them to argument names. For example, in the above example, I could say:

<pre lang='python'>
hello(**{'last':'Lecocq', 'first':'Dan'})
</pre>

Of course, in that case it's a little verbose, but if you're getting a dictionary of arguments programmatically, then it's invaluable. But wait, there's more! Not only can you use the **dict operator to map a dictionary into parameters, but you can accept arbitrary parameters with it, too!

<pre lang='python'>
def kw(**kwargs):
	for key, value in kwargs.items():
		print '%s => %s' % (key, value)

kw(**{'hello':'Howdy!', 'first':'Dan'})
kw(hello='Howdy!', first='Dan')
</pre>

Magic! <strong>No matter how you invoke the function, it has access to the parameters.</strong>  You can even split the difference, making some parameters named and some parameters variable. For example, if you wanted to create an instance of a class that you passed a name in for, initialized with the arguments you give it:

<pre lang='python'>
def factory(module, cls, **kwargs):
	# The built-in __import__ does just what it sounds like
	m = __import__(module)
	# Now get the class in that module
	c = getattr(m, cls)
	# Now make an instance of it, given the args
	return c(**kwargs)

factory('datetime', 'datetime', year=2011, month=11, day=8)
factory('decimal', 'Decimal', value=7)
</pre>

This is one place where Python's flexibility is extremely useful.
